//@version=6
indicator("Combo: Channel + MACD + EXPONOVA", shorttitle="3CStrat", overlay=true, max_bars_back=500)

//───────────────────────────────────────────────────────────────────────
// SEKCJA 1 • PARAMETRY WEJŚCIOWE
//───────────────────────────────────────────────────────────────────────
g_channel = "Ustawienia kanału"
// Zmieniam na input.bool dla każdej reguły, aby działały komplementarnie
use_trend_rule = input.bool(true, "Użyj reguły trendu (T1)", group=g_channel)
use_breakout_rule = input.bool(true, "Użyj reguły breakout (T2)", group=g_channel)
use_inside_rule = input.bool(true, "Użyj reguły inside (T3)", group=g_channel)

period      = input.int(50, "Okres kanału", minval=2, group=g_channel)
chSrcOpt    = input.string("close", "Źródło zakresu", options=["close","high/low"], group=g_channel)
zonePct     = input.float(25, "Procent strefy (reguła 3)", minval=0, maxval=50, group=g_channel) / 100
useSL       = input.bool(false, "Włącz stop-loss", group=g_channel)
slPct       = input.float(5, "Procent stop-loss", minval=0, maxval=100, group=g_channel) / 100
longOnly    = input.bool(false, "Tylko transakcje długie", group=g_channel)

g_macd = "Ustawienia MACD"
fastLen     = input.int(12, "Długość szybkiej MA", minval=1, group=g_macd)
slowLen     = input.int(26, "Długość wolnej MA", minval=1, group=g_macd)
sigLen      = input.int(9, "Długość sygnału", minval=1, group=g_macd)
macdSource  = input.source(close, "Źródło MACD", group=g_macd)
macdMaType  = input.string("EMA", "Typ MA", options=["SMA", "EMA"], group=g_macd)

g_exponova = "Ustawienia EXPONOVA"
emaFastLen  = input.int(18, "Długość szybkiej EMA", minval=1, group=g_exponova)
emaSlowLen  = input.int(50, "Długość wolnej EMA", minval=1, group=g_exponova)
showGradient = input.bool(true, "Pokaż gradient", group=g_exponova)

g_signal = "Sygnały"
signal_weight_macd = input.int(2, "Waga MACD", minval=0, maxval=5, group=g_signal)
signal_weight_trend = input.int(1, "Waga trendu", minval=0, maxval=5, group=g_signal)
signal_weight_channel = input.int(2, "Waga kanału", minval=0, maxval=5, group=g_signal)
confirmation_threshold = input.int(3, "Próg potwierdzenia", minval=1, maxval=8, tooltip="Minimalna łączna waga sygnałów do generowania sygnału", group=g_signal)
require_all_signals = input.bool(false, "Wymagaj wszystkich sygnałów", tooltip="Gdy włączone, wszystkie sygnały (MACD, Trend, Kanał) muszą się zgadzać", group=g_signal)
show_signals = input.bool(true, "Pokaż sygnały na wykresie", group=g_signal)

//───────────────────────────────────────────────────────────────────────
// SEKCJA 2 • LOGIKA KANAŁU CENOWEGO
//───────────────────────────────────────────────────────────────────────
// Funkcja zwraca tuple: [linreg, intercept, slope, signal]
f_lriss(float src, int len) =>
    float lin     = ta.linreg(src, len, 0)
    float linPrev = ta.linreg(src, len, 1)
    float slp     = lin - linPrev
    float sig     = math.sign(slp)
    float ic      = lin - slp * len
    [lin, ic, slp, sig]

// Rozbicie zwróconych wartości
[lreg, intercept, slope, channel_signal] = f_lriss(close, period)

// Wyznaczanie kanału i stref
float b = 0., t = 0.
for i = 0 to period
    b := math.max(b, lreg - i * slope - (chSrcOpt == "close" ? close : low)[i])
    t := math.max(t, (chSrcOpt == "close" ? close : high)[i] - (lreg - i * slope))
upper    = lreg + t + slope
lower    = lreg - b + slope
bandRange = upper - lower
buyZone   = lower + zonePct * bandRange
sellZone  = upper - zonePct * bandRange
// Sygnały kanału (teraz wszystkie reguły mogą działać jednocześnie)
channel_buy_signal_t1 = use_trend_rule and channel_signal == 1 and channel_signal[1] <= 0
channel_sell_signal_t1 = use_trend_rule and channel_signal == -1 and channel_signal[1] >= 0

channel_buy_signal_t2 = use_breakout_rule and close > upper and close[1] <= upper[1]
channel_sell_signal_t2 = use_breakout_rule and close < lower and close[1] >= lower[1]

channel_buy_signal_t3 = use_inside_rule and close <= buyZone and close[1] > buyZone[1] and slope > 0
channel_sell_signal_t3 = use_inside_rule and close >= sellZone and close[1] < sellZone[1] and slope < 0

// Połączone sygnały kanału
channel_buy_signal = channel_buy_signal_t1 or channel_buy_signal_t2 or channel_buy_signal_t3
channel_sell_signal = channel_sell_signal_t1 or channel_sell_signal_t2 or channel_sell_signal_t3

//───────────────────────────────────────────────────────────────────────
// SEKCJA 3 • OBLICZENIA MACD
//───────────────────────────────────────────────────────────────────────
// Obliczanie MACD
fast_ma = macdMaType == "SMA" ? ta.sma(macdSource, fastLen) : ta.ema(macdSource, fastLen)
slow_ma = macdMaType == "SMA" ? ta.sma(macdSource, slowLen) : ta.ema(macdSource, slowLen)
macd_line = fast_ma - slow_ma
signal_line = macdMaType == "SMA" ? ta.sma(macd_line, sigLen) : ta.ema(macd_line, sigLen)
macd_histogram = macd_line - signal_line

// Sygnały MACD
macd_bullish = macd_line > signal_line and macd_line[1] <= signal_line[1]  // Przecięcie bycze
macd_bearish = macd_line < signal_line and macd_line[1] >= signal_line[1]  // Przecięcie niedźwiedzie
macd_bullish_histogram = macd_histogram > 0 and macd_histogram[1] <= 0     // Histogram przechodzi powyżej zera
macd_bearish_histogram = macd_histogram < 0 and macd_histogram[1] >= 0     // Histogram przechodzi poniżej zera

// Połączone sygnały MACD
macd_buy_signal = macd_bullish or macd_bullish_histogram
macd_sell_signal = macd_bearish or macd_bearish_histogram

//───────────────────────────────────────────────────────────────────────
// SEKCJA 4 • PASMO GRADIENT EXPONOVA EMA
//───────────────────────────────────────────────────────────────────────
ema_short = ta.ema(close, emaFastLen)
ema_long = ta.ema(close, emaSlowLen)

// Lista kolorów gradientu
grad = array.from(#f2797d, #f2837e, #f38b7f, #f3957f, #f49d80, #f4a781, #f5af82, #f5b983, #f6c184, #f6cb85, #f7d386, #f2d78e, #eddb96, #e8df9e, #e3e2a6, #dee6ae, #d9e9b7, #d4eebf, #cff1c7, #caf5cf)

// Funkcja określa kolor gradientu
easyColor(cp, e2) =>
    int barsSince = ta.barssince((cp[1] < e2[1] and cp > e2) or (cp[1] > e2[1] and cp < e2))
    int idx = cp > e2 ? barsSince : array.size(grad) - 1 - barsSince
    idx := math.min(math.max(idx, 0), array.size(grad) - 1)
    array.get(grad, idx)

colBand = easyColor(close, ema_long)

// Sygnały trendu
uptrend = ema_short > ema_long
downtrend = ema_short < ema_long
bars_in_uptrend = ta.barssince(not uptrend[1] and uptrend)
bars_in_downtrend = ta.barssince(not downtrend[1] and downtrend)
trend_buy_signal = uptrend and (not uptrend[1] or bars_in_uptrend <= 3)
trend_sell_signal = downtrend and (not downtrend[1] or bars_in_downtrend <= 3)

//───────────────────────────────────────────────────────────────────────
// SEKCJA 5 • GENEROWANIE POŁĄCZONYCH SYGNAŁÓW
//───────────────────────────────────────────────────────────────────────
// Obliczanie ważonej siły sygnału
int buy_strength = 0
int sell_strength = 0

// Dodaj sygnały MACD
buy_strength := buy_strength + (macd_buy_signal ? signal_weight_macd : 0)
sell_strength := sell_strength + (macd_sell_signal ? signal_weight_macd : 0)

// Dodaj sygnały Trendu
buy_strength := buy_strength + (trend_buy_signal ? signal_weight_trend : 0)
sell_strength := sell_strength + (trend_sell_signal ? signal_weight_trend : 0)
buy_strength := buy_strength + (uptrend ? 1 : 0)
sell_strength := sell_strength + (downtrend ? 1 : 0)

// Dodaj sygnały Kanału
buy_strength := buy_strength + (channel_buy_signal ? signal_weight_channel : 0)
sell_strength := sell_strength + (channel_sell_signal ? signal_weight_channel : 0)

// Finalne połączone sygnały
bool combined_buy_signal = false
bool combined_sell_signal = false

if require_all_signals
    // Wszystkie sygnały muszą być obecne
    combined_buy_signal := macd_buy_signal and trend_buy_signal and channel_buy_signal
    combined_sell_signal := macd_sell_signal and trend_sell_signal and channel_sell_signal
else
    // Potwierdzenie na podstawie wag
    combined_buy_signal := buy_strength >= confirmation_threshold
    combined_sell_signal := sell_strength >= confirmation_threshold

// Jeśli longOnly = true, wyłącz sygnały sprzedaży
if longOnly
    combined_sell_signal := false

//───────────────────────────────────────────────────────────────────────
// SEKCJA 6 • WYKRESY I WYPEŁNIENIA
//───────────────────────────────────────────────────────────────────────
// Wykreślenie EMAs trendu
ema_short_plot = plot(ema_short, "Krótka EMA", color=ema_short > ema_short[1] ? #ed7722 : #0e46be, linewidth=2)
ema_long_plot = plot(ema_long, "Długa EMA", color=ema_long > ema_long[1] ? #ed7722 : #0e46be, linewidth=1)

// Dodaj gradient pomiędzy EMAs
color gradientColor = showGradient ? colBand : na
fill(ema_short_plot, ema_long_plot, color.new(gradientColor, 0))

// Elementy kanału - naprawiony błąd z nieistniejącą zmienną rule
p_upper = plot(not use_trend_rule ? upper : na, "Górna wstęga", color=color.new(#ce0e0e, 30), linewidth=1)
p_lower = plot(not use_trend_rule ? lower : na, "Dolna wstęga", color=color.new(#0ece4b, 30), linewidth=1)

// Strefy kupna/sprzedaży dla Rule 3
p_sellzone = plot(use_inside_rule ? sellZone : na, "Strefa sprzedaży", color=color.new(#ce0e0e, 80), linewidth=1)
p_buyzone = plot(use_inside_rule ? buyZone : na, "Strefa kupna", color=color.new(#0ece4b, 80), linewidth=1)

// Wypełnienie stref kanału kolorami
color sellzoneColor = use_inside_rule ? color.new(#ce0e0e, 80) : na
color buyzoneColor = use_inside_rule ? color.new(#0ece4b, 80) : na
fill(p_upper, p_sellzone, sellzoneColor)
fill(p_lower, p_buyzone, buyzoneColor)

// MACD w osobnym panelu
hline(0, "Linia zerowa", color=color.new(#787B86, 50), linestyle=hline.style_dashed)
plot(macd_line, "Linia MACD", color=#2962FF, linewidth=2, display=display.pane)
plot(signal_line, "Linia sygnałowa", color=#FF6D00, linewidth=1, display=display.pane)
macd_hist_color = macd_histogram >= 0 ? (macd_histogram[1] < macd_histogram ? #26A69A : #B2DFDB) : (macd_histogram[1] < macd_histogram ? #FFCDD2 : #FF5252)
plot(macd_histogram, "Histogram", color=macd_hist_color, style=plot.style_columns, display=display.pane)

// Sygnały na wykresie
plotshape(show_signals and combined_buy_signal, "Sygnał kupna", location=location.belowbar, color=color.green, style=shape.labelup, size=size.small, text="BUY", textcolor=color.white)
plotshape(show_signals and combined_sell_signal, "Sygnał sprzedaży", location=location.abovebar, color=color.red, style=shape.labeldown, size=size.small, text="SELL", textcolor=color.white)

// Komponenty z wskaźnikiem siły sygnału
plot(channel_signal, "Sygnał kanału", display=display.none)
plot(math.sign(macd_histogram), "Kierunek MACD", display=display.none)

//───────────────────────────────────────────────────────────────────────
// SEKCJA 7 • ALERTY
//───────────────────────────────────────────────────────────────────────
// Alerty dla sygnałów wejścia/wyjścia
alertcondition(combined_buy_signal, "Sygnał kupna", "Wykryto sygnał kupna")
alertcondition(combined_sell_signal, "Sygnał sprzedaży", "Wykryto sygnał sprzedaży")

// Alerty dla komponentów
alertcondition(macd_buy_signal, "MACD kupno", "Wykryto sygnał kupna MACD")
alertcondition(macd_sell_signal, "MACD sprzedaż", "Wykryto sygnał sprzedaży MACD")
alertcondition(trend_buy_signal, "Trend kupno", "Wykryto sygnał kupna trendu")
alertcondition(trend_sell_signal, "Trend sprzedaż", "Wykryto sygnał sprzedaży trendu")
alertcondition(channel_buy_signal, "Kanał kupno", "Wykryto sygnał kupna kanału")
alertcondition(channel_sell_signal, "Kanał sprzedaż", "Wykryto sygnał sprzedaży kanału")
